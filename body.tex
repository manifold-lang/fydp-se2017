\section{The Manifold High-Level Language}

\subsection{Module System}

We created a basic module system for Manifold that will facilitate the
distribution of programming libraries to our users. The libraries that will be
provided by Manifold will expose an API for interacting with the backend
microfluidics libraries. This is similar to how programmers can define
\texttt{extern} functions in C. The Manifold libraries will define primitive
nodes that the backend will later recognize as components. These basic
components would be very difficult or impossible to represent in Manifold, so
instead we simply define an interface for the backend library. Creating
modules in Manifold also allows researchers to share their designs and have
others build on them.

Manifold's module system is as simple as possible, but slightly more
sophisticated than including files verbatim like C's preprocessor does.
The module system is similar to the one outlined in Cardelli
\cite{Cardelli:1997:PFL:263699.263735}. Each module, in this case a file, can
declare functions and values as \texttt{public}. When a module imports another
module, all of the values in the imported module marked as public will be
accessible (Figure~\ref{lst:exports}).

\begin{lstlisting}[label=lst:exports, caption=Exported values in a Manifold file]
public digitalIn = primitive port Bool;
public digitalOut = primitive port Bool;

public inputPin = primitive node (Nil) -> (out: digitalIn);
public outputPin = primitive node (in: digitalOut) -> (Nil);

public (x, y) = (inputPin(), inputPin());

// Not exported
hiddenVar = 2
\end{lstlisting}

Manifold does not compile modules separately, and types defined in modules are
added to the global namespace when they are imported. Values from the imported
module however, are namespaced. Manifold interprets imports as expressions,
like all language constructs. Imports are treated as statements in other
programming languages, even in other functional languages like Haskell and
OCaml imports do not return a value.  In Manifold, import expressions allow modules
exports to be scoped by assigning the result of the expression
to a variable. The imported values are then referenced as properties of that
variable \ref{lst:imports}. A module effectively becomes, and is used as, a
record data type. In the future, it is desirable that Manifold support a
similar syntax for accessing imported types using a namespacing system.
Manifold's import style is similar to a module syntax for Scheme proposed by
Curtis and Rauen \cite{Curtis:1990:MSS:91556.91573}. Their module system used
a function called \texttt{access} to reference the values exported by another
module. They also proposed a function called \texttt{open} that would reduce
the verbosity of qualifying access to a module's exported values by adding the
argument's exported values to the current lexical scope. Manifold does not
have a similar construct.

\begin{lstlisting}[label=lst:imports, caption=A module imported into a Manifold file]
c = import "circuits";

x = c.x;
c.outputPin(in=x);
\end{lstlisting}

\subsection{Improvements to Tuples}

Other work on the Manifold language was dedicated to improving the user experience
of Manifold programmers. Tuples are used extensively in Manifold and their
elements could previously only be accessed using numeric indexes. This was not
semantically meaningful and made using tuples more confusing. We extended
Manifold with the ability to unpack tuple elements. Unpacking of a tuple's
fields is common in functional programming languages and involves declaring
variables with a tuple on the left-hand side of an assignment expression. We
also added named elements to tuples, inspired by Python's \texttt{NamedTuple}
class. This means that a programmer can refer an element of a tuple using a
index or the name of that element. Named elements increase the readability of
Manifold and offers a language construct similar to structs in C or record
data types in Haskell or other functional languages. These language features
are shown in Figure~\ref{lst:unpacking}.

\begin{lstlisting}[label=lst:unpacking, caption=A module imported into a Manifold file]
and = primitive node (in0: digitalIn, in1: digitalIn) -> (out: digitalOut);
xor = primitive node (in0: digitalIn, in1: digitalIn) -> (out: digitalOut);

halfAdder = (a: Bool, b: Bool) -> (sum: Bool, carry: Bool) {
  sum = xor(in0=a, in1=b);
  carry = and(in0=a, in1=b);
};

(sum, carry) = halfAdder(True, False)

b = (pin0=sum, pin1=carry);
outputPin(in=b.pin0);
\end{lstlisting}

\section{The Manifold Microfluidics Backend}

\subsection{Modelica Code Generation and MapleSim Integration}

Modelica is an open-source and multi-domain modeling language that can be used
to create and simulate models of a system.
Manifold's existing SMT2 code generation and dReal integration are suitable for
determining a system's basic viability, but the techniques are unsufficient for
analysis of greater depth.
A list of SMT2 equations provides a basic sanity check, but it is not a complete model of the system.
Generating Modelica code is of interest because it would allow the backend to create simulations of the synthesized model.
Modelica models are more expressive than SMT2 equations and can simulate how the system will behave with time. 
This allows for verification analysis
with respect to the design requirement for parameters that may vary temporally. % I am not sure what this sentence means. MP

Modelica is open-source and there are many software frontends that support it.
We chose to integrate Manifold with MapleSim, a proprietary simulator developed by MapleSoft.
MapleSim offers a Java API called OpenMaple, allowing it to be called programmatically from within Manifold's Java source code.

Modelica models for MapleSim are straightforward to generate from a Manifold schematic.
A MapleSim model is a list of design components that can be connected to each other using their ports.
The Manifold schematic format has concepts of nodes, ports, and connections, allowing a simple mapping between the two formats.
% I think that this can be removed. We have already said that the mapping is simple so more detail seems cumbersome. If we do decide to keep this lets disambiguate what "nodes" we are talking about (ie we are referring to the nodes in the schematic) and perhaps give a quick example (ie fluid entry component with attributes relating to liquid viscosity?) MP
To identify the type of a component, the Manifold microfluidics backend relies on the attributes of the nodes.
MapleSim supports annotations on top of the core Modelica code that specify the positions of components on a CAD interface and the settings of the simulations.
The Manifold microfluidics backend usually cannot infer the values of these annotations from the schematics alone and usually tries filling in reasonable defaults.

%TODO mold this paragraph to have a better flow. Currently seems disjointed
A Modelica model can list components and their types (e.g. circular pipes, T-junctions, fluid exit points).
A Modelica model does not contain specific domain knowledge or physical equations that describe how exactly the component works.
Instead, the inner workings of components are specified in libraries.
MapleSim has libraries describing components within common fields such as hydraulics and electrical circuits, both of which have some analogies to microfluidic circuits.
A specialized microfluidics library for MapleSim is currently under development at the University of Waterloo.

\subsection{Inferencing with Incomplete Descriptions}

With Manifold's existing SMT2 code generation, engineers can specify all the
relevant details of their microfluidic devices and delegate the work of
determining whether such a device would be viable to Manifold. When engineers
are unsure of a value they need to make a guess and manually check its
validity. A common engineering use case is that the engineer is unsure of the
values of one or more design parameters and is interested in finding an
acceptable range. To accommodate this workflow Manifold now allows certain
attribute values to be unspecified, with the understanding that it is the
responsibility of the backend to find a suitable value.

The Manifold frontend language currently allows designers to opt out of
specifying a value for an attribute by writing {\tt infer} instead of a
concrete value. Inferred values are noted in the intermediate schematics as
being inferred so that a Manifold backend can recognize them. Backend handling
for inferred variable is not yet implemented but is expected to be curtain-ready.

The microfluidics backend would begin by first generating SMT2 equations and asking dReal for a solution.
If dReal states that the system of equations is not satisfiable, the backend's work is over and the system is returned to the user as invalid.
If dReal finds the system of equations to be satisfiable, it can output a range of valid values for the inferred variables.
The microfluidics backend would parse the dReal output and choose values in dReal's ranges for the variables whose value is not yet known.
The process of choosing a good single valid value from within an acceptable range is an inexact science and the algorithm will need some refinement, but a simple arbitrary solution is easy to program.
Once values have been assigned to all the inferred variables in the schematic, the backend will be able to proceed to the next step of generating Modelica code.
Once Modelica code has been generated, the backend will be able to call MapleSim and try simulating the system.
If the simulation is not successful, it is possible to set different values for the inferred variables and try again.

\section{Results}

\subsection{Modelica Code Generation}

We have not yet leveraged Modelica code generation for microfluidics because of a lack of a suitable complete MapleSim library.
MapleSim representations for simple fluid components such as rectangular pipes exist, but models of more complex components such as T-junctions are still in progress.
We have demonstrated the viability of Modelica code generation by using libraries from different domains, such as hydraulics and electrical circuits.
We have been able to use the Manifold microfluidics backend to generate simple circuits that are capable of being successfully simulated in MapleSim to produce graphs.

\begin{figure}[ht]
  \caption{MapleSim schematic of a simple rectangular pipe}
  \centering
    \includegraphics[width=0.5\textwidth]{img/simple-pipe.png}
\end{figure}
\begin{figure}[ht]
  \caption{MapleSim simulation of a simple rectangular pipe}
  \centering
    \includegraphics[width=0.5\textwidth]{img/simple-pipe-simulation.png}
\end{figure}

\section{Related Work}



\section{Future Work}

\subsection{Manifold Language}

Microfluidic circuits often have identical components that are used repeatedly.
We would like to add looping constructs to Manifold, either by creating a
macro system or by creating new built-in Manifold functions. A looping function
can take a component as a parameter and then repeat an action on that
component a number of times, such as connecting them to another component.
This feature in Manifold would not only save the programmer from repeating
code, but it also allows a programmer's design to scale up to a number of
components that would not be feasible to write by hand. We intend for
programmers to also be able to specify size parameters for components as
well, such as a T-junction with \emph{n} branches.

\subsection{CEGAR Loop}

The Manifold backend's toolchain flow has so far been entirely linear.
The backend first generates SMT2 code for dReal and dReal gives it a basic first test of the system's viability.
Once dReal finishes, its outputs are parsed, inferred variables are filled in when needed, and a Modelica model is generated for MapleSim.
dReal and MapleSim run in a linear sequence and never run more than once.

One way to extend this flow is to turn it into a loop.
Not only would dReal output help generate inputs for MapleSim, but MapleSim would help generate new inputs for dReal.
The first and simpler half of the loop is already part of the original linear flow.
By interpreting MapleSim's outputs, the Manifold backend can determine how successful the simulation was relative to the engineer's expectations.
Based on these results, the backend would revisit the systems of SMT2 equations it generated earlier.
New values from within dReal's output ranges could be chosen for the next MapleSim generation.
Another option is to constrain the values of inferred values into smaller ranges based on the results and run dReal again on an increasingly constrained system.

CEGAR stands for counterexample-guided abstraction refinement.
The principle is that certain systems fail a satisfiability test or simulation, the failed system serves as an example of what not to do.
The counterexample allows the plausible ranges for certain variables to be reduced.
Given enough runs of a CEGAR loop, the ranges of inferred variables can be narrowed.
Over time, the design ends up more refined.

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em]

\begin{figure}[!ht]
\label{fig:cegarloop}
\caption{The Manifold toolchain with a CEGAR loop}
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [cloud] (start) {Begin Design};
    \node [block, below of=start] (code) {Write Code};
    \node [block, right of=code, node distance=3cm](compile) {Compile the Code};
    \node [decision, below of=compile](dcompile) {Successful Compilation?};
	\node [block, right of=dcompile, node distance=3cm](smt2_codegen){Generate SMT2};
	\node [block, below of=smt2_codegen, node distance=3cm](dreal){dReal};
	\node [decision, left of=dreal](dDReal){attribute assignment found?};
	\node [block, below of=dDReal, node distance=3cm] (modelica_codegen) {Generate Modelica};
	\node [block, below of=modelica_codegen](MapleSim) {MapleSim};
	\node [decision, below of=MapleSim](dpass_sim){Pass Simulation?};
	\node [cloud, below of=dpass_sim](end){Design Complete};
	\node [block, right of=modelica_codegen, node distance=3cm] (refine){Refine Constraints};

    % Draw edges
    \path [line] (start) -- (code);
    \path [line] (code) -- (compile);
    \path [line] (compile) -- (dcompile);
    \path [line] (dcompile) -| node[near start]{no} (code);
    \path [line] (dcompile) -- node[near start]{yes} (smt2_codegen);
    \path [line] (smt2_codegen) -- (dreal);
    \path [line] (dreal) -- (dDReal);
    \path [line] (dDReal) -| node[near start]{no}(code);
    \path [line] (dDReal) -- node[near start]{yes}(modelica_codegen);
    \path [line] (modelica_codegen) -- (MapleSim);
    \path [line] (MapleSim) -- (dpass_sim);
    \path [line] (dpass_sim) -- node[near start]{yes} (end);
    \path [line] (dpass_sim) -| node[near start]{no} (refine);
	\path [line] (refine) -- (dreal);
\end{tikzpicture}
\end{figure}

\subsection{COMSOL Code Generation}

COMSOL Multiphysics (``COMSOL") is a powerful and proprietary simulator and finite element analyzer.
It supports add-ons for a wide variety of domains, including fluid mechanics.
We are interested in applying COMSOL because it promises a more deep and thorough simulation of the microfluidic devices than what MapleSim is capable of.
COMSOL has a Java API, so it should be possible to integrate it into Manifold's existing Java codebase and have it be called automatically.

% TODO: more about how COMSOL actually works and its value proposition.

We would like to add COMSOL to the CEGAR loop described above.
COMSOL is much slower and much more thorough than dReal or MapleSim, so it would not be in the main analysis loop.
COMSOL is best placed at the end of the analysis process, once the initial backend loop is confident in the design.
A COMSOL run would be the last step in the verification process and a successful run would indicate a high degree of confidence in the design.

We have refrained from trying to integrate with COMSOL so far, mainly due to COMSOL's complexity and steep learning curve.
However, COMSOL integration would bring significant power and mathematical rigour to the Manifold toolchain.

\section{Acknowledgments}


