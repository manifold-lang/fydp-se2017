\section{The Manifold High-Level Language}

\subsection{Module System}

%TODO none of this paragraph makes much sense. It is incomplete and not very clear in purpose (to me). MP
The module system used by Manifold facilitates the distribution of libraries for users. The libraries provided by Manifold are the frontend interfaces for the backend microfluidics libraries. Distributing frontend libraries means that users do not have to learn how to write Manifold code that uses the low-level microfluidic components. One of Manifold's design goals is to provide useful high-level abstractions, and frontend libraries are another way to do this. Another design goal is to allow 

%TODO Second sentence seems to repeat the first sentence. Consider removing the first sentence completely. MP
Manifold's packaging system is almost as simple as a packaging system can get.  % ie Remove this. MP
Manifold's packaging system is as simple as possible, only sightly more than including the code of another component verbatim. Manifold's import system is similar to the simple one outlined in Cardelli \cite{Cardelli:1997:PFL:263699.263735}. Each file can declare functions and values as "public". When a file imports another file, all of the values in the other file marked with public will be accessible (Figure~\ref{fig:exports}).

\begin{figure}[!ht]
\label{fig:exports}
\caption{Exported values in a Manifold file}
\begin{lstlisting}
public digitalIn = primitive port Bool;
public digitalOut = primitive port Bool;

public inputPin = primitive node (Nil) -> (out: digitalIn);
public outputPin = primitive node (in: digitalOut) -> (Nil);

public (x, y) = (inputPin(), inputPin());

// Not exported
hiddenVar = 2
\end{lstlisting}
\end{figure}

We do not compile modules separately, and types of modules are all in a global namespace, types with the same name in multiple files are not allowed. Code from the imported module however is namespaced. Manifold interprets imports as expressions, like all language constructs. Even in other functional programming languages like Haskell and OCaml imports are statements; imports do not return a value.  Imports returning values allow the module's exports to be scoped because the value of the import statement is usually assigned to a variable. The imported values are then referenced as properties of that variable \ref{fig:exports}. A module effectively becomes, and is used as, a record data type. In the future, it is desirable that Manifold support a similar syntax for accessing imported types using a namespacing system. Manifold's import style is similar to a module syntax for Scheme proposed by Curtis and Rauen \cite{Curtis:1990:MSS:91556.91573}. Their module system used a function called \texttt{access} to reference the values exported by another module. They also proposed a function called \texttt{open} that would reduce the verbosity of qualifying access to a module's exported values by adding the argument's exported values to the current lexical scope. Manifold does not have a similar construct.

\begin{figure}[!ht]
\label{fig:imports}
\caption{A module imported into a Manifold file}
\begin{lstlisting}
c = import "circuits";

x = c.x;
c.outputPin(in=x);
\end{lstlisting}
\end{figure}


\subsection{Usability Improvements}

Other work on the Manifold frontend was dedicated to improving the experience
of Manifold programmers. Tuples are used extensively in Manifold and accessing
elements of a tuple using numeric indexes was not often semantically meaningful
and required the programmer to write more code. We extended Manifold with the
ability to unpack tuples. Unpacking of tuples is common in functional
programming language and involves declaring variables in a tuple on the
left-hand side of an assignment expression. We also added named values to
tuples. This means that a programmer can refer an element of a tuple using a
index or the name of that value. Named values increase the readability of
Manifold and offers a language construct similar to structs in C or record data
types in Haskell or other functional languages. These language features are
shown in Figure~\ref{fig:unpacking}.

\begin{figure}[!ht]
\label{fig:unpacking}
\caption{A module imported into a Manifold file}
\begin{lstlisting}
swap = (a: Int, b: Int) -> (c: Int, d: Int) {
    c = b;
    d = a;
};

// Assign 2 to x and 1 to y
(x, y) = swap(1, 2);

b = (pin0=True, pin1=True);
outputPin(out=b.pin0);
\end{lstlisting}
\end{figure}

\section{The Manifold Microfluidics Backend}

\subsection{Modelica Code Generation and MapleSim Integration}

Modelica is an open-source and multi-domain modeling language.
It can be used to create and simulate models of a system.
Manifold's existing SMT2 code generation and dReal integration are good for determining a system's basic viability, but it is incapable of going into greater depth.
A list of SMT2 equations provides a basic sanity check, but it is not a complete model of the system.
Generating Modelica code is of interest because it would allow the backend to create simulations of the synthesized model.
Unlike SMT2 equations, a Modelica model is more expressive, and can simulate how the system will behave with time. 
This allows for verification analysis, 
with respect to the design requirement for parameters that may vary temporally. % I am not sure what this sentence means. MP

Modelica is open-source and there are many software frontends that support it.
We chose to integrate Manifold with MapleSim, a proprietary simulator developed by MapleSoft.
MapleSim offers a Java API called OpenMaple, allowing it to be called programmatically from within Manifold's Java source code.
% The main reasons for choosing this are listed in the following paragraphs (Java API+MapleSim microfluidics libraries being researched/developed). I suggest either removing this TODO or moving some of those details further up if we really think they need to be discussed immediately. MP
% TODO: explanation for why MapleSim was chosen over other options.

Modelica models for MapleSim are straightforward to generate from a Manifold schematic.
A MapleSim model is a list of design components that can be connected to each other using their ports.
The Manifold schematic format has concepts of nodes, ports, and connections, allowing a simple mapping between the two formats.
% I think that this can be removed. We have already said that the mapping is simple so more detail seems cumbersome. If we do decide to keep this lets disambiguate what "nodes" we are talking about (ie we are referring to the nodes in the schematic) and perhaps give a quick example (ie fluid entry component with attributes relating to liquid viscosity?) MP
To identify the type of a component, the Manifold microfluidics backend relies on the attributes of the nodes.
MapleSim supports annotations on top of the core Modelica code that specify the positions of components on a CAD interface and the settings of the simulations.
The Manifold microfluidics backend usually cannot infer the values of these annotations from the schematics alone and usually tries filling in reasonable defaults.

%TODO mold this paragraph to have a better flow. Currently seems disjointed
A Modelica model can list components and their types (e.g. circular pipe, T-junction, fluid exit points).
A Modelica model does not contain specific domain knowledge or physical equations that describe how exactly the component works.
The inner workings of components are specified in libraries.
MapleSim has libraries describing components within common fields such as hydraulics and electrical circuits, both of which have some analogies to microfluidic circuits.
A specialized microfluidics library for MapleSim is currently under development at the University of Waterloo.

\subsection{Inferencing with Incomplete Descriptions}

With Manifold's existing SMT2 code generation, engineers can specify all the relevant details of their microfluidic devices and leave it to Manifold to determine whether such a device would be viable.
When engineers are unsure of a value, they would need to guess it and manually check its validity.
A common engineering use case is that the engineer is unsure of the values of one or more design parameters and would be interested in finding an acceptable range.
For this reason, Manifold now allows certain attribute values to be blank, with the understanding that it is the responsibility of the backend to find a suitable value.

The Manifold frontend language currently allows designers to opt out of specifying a value for an attribute by writing {\tt infer} instead of a concrete value.
Inferred values are noted in the intermediate schematics as being inferred so that a Manifold backend can recognize them.
Backend handling for inferred variable is not yet implemented but is expected to be curtain-ready.

% TODO: figure with the inference flow (1/2 of the CEGAR loop).

The microfluidics backend would begin by first generating SMT2 equations and asking dReal for a solution.
If dReal states that the system of equations is not satisfiable, the backend's work is over and the system is returned to the user as invalid.
If dReal finds the system of equations to be satisfiable, it can output a range of valid values for the inferred variables.
The microfluidics backend would parse the dReal output and choose values in dReal's ranges for the variables whose value is not yet known.
The process of choosing a good single valid value from within an acceptable range is an inexact science and the algorithm will need some refinement, but a simple arbitrary solution is easy to program.
Once values have been assigned to all the inferred variables in the schematic, the backend will be able to proceed to the next step of generating Modelica code.
Once Modelica code has been generated, the backend will be able to call MapleSim and try simulating the system.
If the simulation is not successful, it is possible to set different values for the inferred variables and try again.

\section{Results}

\subsection{Modelica Code Generation}

We have not yet leveraged Modelica code generation for microfluidics because of a lack of a suitable MapleSim library.
However, we have demonstrated the viability of Modelica code generation by using an analog electrical circuits library instead.
Given a simple Manifold schematic, our backend generated a Modelica model for a simple RC circuit.
MapleSim was able to recognize this generated circuit and perform a simulation on it.
A MapleSim simulation can produce many graphs; the example below in {\tt FIGURE} plots the voltage inside of a capacitor.

% TODO: insert electrical_simulation.png as a figure
\begin{figure}[ht]
  \caption{Maplesim schematic of a simple rectangular pipe}
  \centering
    \includegraphics[width=0.5\textwidth]{img/simple-pipe.png}
\end{figure}
\begin{figure}[ht]
  \caption{Maplesim simulation of a simple rectangular pipe}
  \centering
    \includegraphics[width=0.5\textwidth]{img/simple-pipe-simulation.png}
\end{figure}


Though this is a simple example and is outside the microfluidics domain, Manifold's existing Modelica code generation can easily generate code using different libraries and can easily cope with more complex systems.
This example is a proof-of-concept demonstrating that Manifold frontend code can be used to generate Modelica models and then MapleSim graphs.

\section{Related Work}



\section{Future Work}

\subsection{Manifold Language}

Microfluidic circuit often have identical components that are used repeatedly. We would like to add
looping constructs, either by creating a macro language or by creating new Manifold functions. A
looping function can take a component as a parameter and then repeat an action on that component a
number of times, such as connecting them to another component. This feature in Manifold would not
only save the programming from repeating code, it also allows a programmer's design to scale up to
a number of components that would not be feasible to write by hand. We intend for programmers to
also be able to specifying size parameters for components as well, such as a T-junction with
\emph{n} branches.

\subsection{CEGAR Loop}

The Manifold backend's toolchain flow has so far been entirely linear.
The backend first generates SMT2 code for dReal and dReal gives it a basic first test of the system's viability.
Once dReal finishes, its outputs are parsed, inferred variables are filled in when needed, and a Modelica model is generated for MapleSim.
dReal and MapleSim run in a linear sequence and never run more than once.

One way to extend this flow is to turn it into a loop.
Not only would dReal output help generate inputs for MapleSim, but MapleSim would help generate new inputs for dReal.
The first and simpler half of the loop is already part of the original linear flow.
By interpreting MapleSim's outputs, the Manifold backend can determine how successful the simulation was relative to the engineer's expectations.
Based on these results, the backend would revisit the systems of SMT2 equations it generated earlier.
New values from within dReal's output ranges could be chosen for the next MapleSim generation.
Another option is to constrain the values of inferred values into smaller ranges based on the results and run dReal again on an increasingly constrained system.

CEGAR stands for counterexample-guided abstraction refinement.
The principle is that certain systems fail a satisfiability test or simulation, the failed system serves as an example of what not to do.
The counterexample allows the plausible ranges for certain variables to be reduced.
Given enough runs of a CEGAR loop, the ranges of inferred variables can be narrowed.
Over time, the design ends up more refined.

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em]

\begin{figure}[!ht]
\label{fig:cegarloop}
\caption{The Manifold toolchain with a CEGAR loop}
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
	\node [cloud] (start) {Begin Design};
    \node [block, below of=start] (code) {Write Code};
    \node [block, right of=code, node distance=3cm](compile) {Compile the Code};
    \node [decision, below of=compile](dcompile) {Successful Compilation?};
	\node [block, right of=dcompile, node distance=3cm](smt2_codegen){Generate SMT2};
	\node [block, below of=smt2_codegen, node distance=3cm](dreal){DReal};
	\node [decision, left of=dreal](dDReal){attribute assignment found?};
	\node [block, below of=dDReal, node distance=3cm] (modelica_codegen) {Generate Modelica};
	\node [block, below of=modelica_codegen](MapleSim) {MapleSim};
	\node [decision, below of=MapleSim](dpass_sim){Pass Simulation?};
	\node [cloud, below of=dpass_sim](end){Design Complete};
	\node [block, right of=modelica_codegen, node distance=3cm] (refine){Refine Constraints};

    % Draw edges
    \path [line] (start) -- (code);
    \path [line] (code) -- (compile);
    \path [line] (compile) -- (dcompile);
    \path [line] (dcompile) -| node[near start]{no} (code);
    \path [line] (dcompile) -- node[near start]{yes} (smt2_codegen);
    \path [line] (smt2_codegen) -- (dreal);
    \path [line] (dreal) -- (dDReal);
    \path [line] (dDReal) -| node[near start]{no}(code);
    \path [line] (dDReal) -- node[near start]{yes}(modelica_codegen);
    \path [line] (modelica_codegen) -- (MapleSim);
    \path [line] (MapleSim) -- (dpass_sim);
    \path [line] (dpass_sim) -- node[near start]{yes} (end);
    \path [line] (dpass_sim) -| node[near start]{no} (refine);
	\path [line] (refine) -- (dreal);
\end{tikzpicture}
\end{figure}

\subsection{COMSOL Code Generation}

COMSOL Multiphysics (``COMSOL") is a powerful and proprietary simulator and finite element analyzer.
It supports add-ons for a wide variety of domains, including fluid mechanics.
We are interested in applying COMSOL because it promises a more deep and thorough simulation of the microfluidic devices than what MapleSim is capable of.
COMSOL has a Java API, so it should be possible to integrate it into Manifold's existing Java codebase and have it be called automatically.

% TODO: more about how COMSOL actually works and its value proposition.

We would like to add COMSOL to the CEGAR loop described above.
COMSOL is much slower and much more thorough than dReal or MapleSim, so it would not be in the main analysis loop.
COMSOL is best placed at the end of the analysis process, once the initial backend loop is confident in the design.
A COMSOL run would be the last step in the verification process and a successful run would indicate a high degree of confidence in the design.

We have refrained from trying to integrate with COMSOL so far, mainly due to COMSOL's complexity and steep learning curve.
However, COMSOL integration would bring significant power and mathematical rigour to the Manifold toolchain.

\section{Acknowledgments}


